{"version":3,"sources":["routes.js","../../taoTaskQueue/model/taskQueueModel.js","synchronizer/index.js"],"names":["define","Synchronizer","actions","index","$","_","Promise","eventifier","polling","request","hasSameState","task1","task2","status","_defaults","url","get","archive","all","download","pollSingleIntervals","iteration","interval","pollAllIntervals","config","model","_cache","singlePollings","getPollSingleIntervals","isArray","cloneDeep","getPollAllIntervals","defaults","setEndpoints","urls","assign","this","taskId","TypeError","then","taskData","id","trigger","reject","Error","catch","err","getAll","limit","newCache","forEach","task","difference","keys","res","pollAll","immediate","self","loop","pollingIntervals","_updateInterval","pollingInstance","pollingInterval","shift","setInterval","globalPolling","start","action","statusArr","done","async","taskDataArray","map","indexOf","resolve","next","pollAllStop","stop","pollSingle","poll","finished","pollSingleStop","create","data","taskCreate","creationResult","result","extra","fileDownload","httpMethod","successCallback","failCallback","moment","urlHelper","taskQueueModelFactory","loadingBar","tq","api","ext","webservices","route","lastTask","taskLabel","getData","label","$formFields","each","name","value","toggleLaunchButtonState","isValid","validity","valid","$launchButton","removeAttr","attr","setState","state","$container","removeClass","className","match","join","$spinner","addClass","msg","$all","hide","updateTime","setTime","createdAt","createdAtElapsed","timestamp","type","timeFields","text","unix","format","show","setHistoryTime","$form","find","$enqueued","$updated","$completed","_msg","$currentMsg","taskQueue","Number","MAX_SAFE_INTEGER","on","updatedAt","e","preventDefault","currentTask"],"mappings":"AAmBAA,OAAA,+BAAA,WACA,YAEA,QACAC,cACAC,SACAC,MAAA,6CCUAH,OAAA,qCACA,SACA,SACA,eACA,kBACA,eACA,4BACA,uBACA,SAAAI,EAAAC,EAAAC,QAAAC,WAAAC,QAAAC,SACA,YAwBA,SAAAC,cAAAC,MAAAC,OACA,MAAAD,OAAAE,SAAAD,MAAAC,SAEA,YAAAF,MAAAE,QAAA,gBAAAF,MAAAE,UACA,YAAAD,MAAAC,QAAA,gBAAAD,MAAAC,QA1BA,GAAAC,YACAC,KACAC,IAAA,GACAC,QAAA,GACAC,IAAA,GACAC,SAAA,IAEAC,sBACAC,UAAA,EAAAC,SAAA,MAEAC;AACAF,UAAA,GAAAC,SAAA,MACAD,UAAA,EAAAC,SAAA,MAoCA,OAAA,UAAAE,QAEA,GAAAC,OAMAC,OAMAC,kBAEAC,uBAAA,WACA,GAAAJ,OAAAJ,qBAAAf,EAAAwB,QAAAL,OAAAJ,qBACA,MAAAf,GAAAyB,UAAAN,OAAAJ,sBAIAW,oBAAA,WACA,GAAAP,OAAAD,kBAAAlB,EAAAwB,QAAAL,OAAAD,kBACA,MAAAlB,GAAAyB,UAAAN,OAAAD,kBAmXA,OA/WAC,QAAAnB,EAAA2B,SAAAR,WAAAV,WAKAW,MAAAlB,YAOA0B,aAAA,SAAAC,MAEA,MADA7B,GAAA8B,OAAAX,OAAAT,IAAAmB,UACAE,MASApB,IAAA,SAAAqB,QACA,GAAAxB,OAEA,KAAAW,OAAAT,MAAAS,OAAAT,IAAAC,IACA,KAAA,IAAAsB,WAAA;AA4BA,MAzBAzB,QAAAJ,QAAAe,OAAAT,IAAAC,KAAAqB,OAAAA,QAAA,UAAA,GACAE,KAAA,SAAAC,UAEA,MAAAA,WAAAA,SAAA3B,QACAa,OAEAA,OAAAc,SAAAC,IAEA/B,aAAAgB,OAAAc,SAAAC,IAAAD,WAEAf,MAAAiB,QAAA,yBAAAF,UAHAf,MAAAiB,QAAA,kBAAAF,UAMAd,UAEAA,OAAAc,SAAAC,IAAAD,SACAA,UAEAlC,QAAAqC,OAAA,GAAAC,OAAA,8BAGA/B,OAAAgC,MAAA,SAAAC,KACArB,MAAAiB,QAAA,QAAAI,OAGAjC,QAQAkC,OAAA,WACA,GAAAlC,OAEA,KAAAW,OAAAT,MAAAS,OAAAT,IAAAG,IACA,KAAA,IAAAoB,WAAA,kEAwCA,OArCAzB,QAAAJ,QAAAe,OAAAT,IAAAG,KAAA8B,MAAA,KAAA,UAAA,GACAT,KAAA,SAAAC;AACA,GAAAS,YAEA,OAAAT,WACAd,QAEArB,EAAA6C,QAAAV,SAAA,SAAAW,MACA,GAAAV,IAAAU,KAAAV,EACAf,QAAAe,IAEA/B,aAAAgB,OAAAe,IAAAU,OAEA1B,MAAAiB,QAAA,wBAAAS,MAHA1B,MAAAiB,QAAA,iBAAAS,MAKAF,SAAAR,IAAAU,OAEA9C,EAAA6C,QAAA7C,EAAA+C,WAAA/C,EAAAgD,KAAA3B,QAAArB,EAAAgD,KAAAJ,WAAA,SAAAR,IACAhB,MAAAiB,QAAA,cAAAhB,OAAAe,QAGApC,EAAA6C,QAAAV,SAAA,SAAAW,MACAF,SAAAE,KAAAV,IAAAU,OAIAzB,OAAAuB,SAEAT,UAEAlC,QAAAqC,OAAA,GAAAC,OAAA,kCAGA/B,OAAAgC,MAAA,SAAAC,KACArB,MAAAiB,QAAA,QAAAI,OAGAjC,QASAI,QAAA,SAAAoB,QAEA,GAAAxB,OAEA,KAAAW,OAAAT,MAAAS,OAAAT,IAAAE,QACA,KAAA,IAAAqB,WAAA;AASA,MANAzB,QAAAJ,QAAAe,OAAAT,IAAAE,SAAAoB,OAAAA,QAAA,UAAA,GAEAxB,OAAAgC,MAAA,SAAAS,KACA7B,MAAAiB,QAAA,QAAAY,OAGAzC,QAQA0C,QAAA,SAAAC,WAEA,GAAAC,MAAArB,KACAsB,KAAA,EACAC,iBAAA5B,sBAOA6B,gBAAA,SAAAC,iBACA,GAAAC,gBACAJ,MACAA,QAEAI,gBAAAH,iBAAAI,QACAD,iBAAA,mBAAAA,iBAAAzC,WAAAyC,gBAAAxC,WACAoC,KAAAI,gBAAAzC,UACAwC,gBAAAG,YAAAF,gBAAAxC,YAKA,KAAAE,OAAAT,MAAAS,OAAAT,IAAAG,IACA,KAAA,IAAAoB,WAAA,mEAuCA,OApCAF,MAAA6B,eA2BA7B,KAAA6B,cAAAC;AACA9B,KAAAM,QAAA,kBA1BAN,KAAA6B,cAAAzD,SACA2D,OAAA,WAEA,GACAC,WADAC,KAAAjC,KAAAkC,OAEA7C,OAAAsB,SAAAR,KAAA,SAAAgC,eAKA,MAJA9C,OAAAiB,QAAA,UAAA6B,eAGAH,UAAA/D,EAAAmE,IAAAD,cAAA,UACAH,UAAAK,QAAA,kBAAA,GAAAL,UAAAK,QAAA,cAAA,EACAJ,KAAA1B,UAGAiB,gBAAAH,KAAAQ,mBACAI,MAAAK,aACA7B,MAAA,WACAwB,KAAA1B,cAIAiB,gBAAAxB,KAAA6B,eACA7B,KAAA6B,cAAAC,QACA9B,KAAAM,QAAA,iBAMAc,WAEApB,KAAA6B,cAAAU,OAGAlD,OAOAmD,YAAA,WAKA,MAJAxC,MAAA6B,gBACA7B,KAAA6B,cAAAY,OACAzC,KAAAM,QAAA,gBAEAN;EAQA0C,WAAA,SAAAzC,QAEA,GAAAoB,MAAArB,KACAsB,KAAA,EAEAC,iBAAA/B,yBAOAgC,gBAAA,SAAAC,iBACA,GAAAC,gBACA,OAAAJ,OACAA,QACA,IAEAI,gBAAAH,iBAAAI,WACAD,iBAAAA,gBAAAzC,WAAAyC,gBAAAxC,YACAoC,KAAAI,gBAAAzC,UACAwC,gBAAAG,YAAAF,gBAAAxC,WACA,IAQA,KAAAE,OAAAT,MAAAS,OAAAT,IAAAC,IACA,KAAA,IAAAsB,WAAA,sEAOA,OAJAX,gBAAAU,SACAV,eAAAU,QAAAwC,OAGA,GAAAvE,SAAA,SAAAoE,SACA,GAAAK,MAAAvE,SACA2D,OAAA,WAEA,GAAAE,MAAAjC,KAAAkC,OACAb,MAAAzC,IAAAqB,QAAAE,KAAA,SAAAC;AACA,cAAAA,SAAA3B,QAAA,WAAA2B,SAAA3B,QAEAkE,KAAAF,OACApB,KAAAf,QAAA,qBAAAL,OAAAG,UACAkC,SAAAM,UAAA,EAAA7B,KAAAX,YACAoB,gBAAAmB,OAKAtB,KAAAf,QAAA,aAAAL,OAAAG,UACA6B,KAAAK,YAJAjB,KAAAf,QAAA,qBAAAL,OAAAG,UACAkC,SAAAM,UAAA,EAAA7B,KAAAX,cAMAK,MAAA,WACAwB,KAAA1B,aAIAiB,iBAAAmB,MACApD,eAAAU,QAAA0C,KAAAb,QACAT,KAAAf,QAAA,kBAAAL,WASA4C,eAAA,SAAA5C,QAKA,MAJAV,iBAAAA,eAAAU,UACAV,eAAAU,QAAAwC,OACAzC,KAAAM,QAAA,iBAAAL,SAEAD,MASA8C,OAAA,SAAAnE,IAAAoE,MACA,GAAAC,YAAA3B,KAAArB;AA2BA,MA1BAgD,YAAA3E,QAAAM,IAAAoE,KAAA,WAAA,GACA5C,KAAA,SAAA8C,gBAEA,MAAAA,iBAAAA,eAAAlC,MAAAkC,eAAAlC,KAAAV,IACAgB,KAAAf,QAAA,UAAA2C,gBACA5B,KAAAqB,WAAAO,eAAAlC,KAAAV,IAAAF,KAAA,SAAA+C,QAWA,MAVAD,gBAAAE,QACAD,OAAAC,MAAAF,eAAAE,OAEAD,OAAAN,SAEAvB,KAAAf,QAAA,eAAA4C,QAGA7B,KAAAf,QAAA,WAAA4C,QAEAA,UAGAhF,QAAAqC,OAAA,GAAAC,OAAA,8BAGAwC,WAAAvC,MAAA,SAAAC,KACArB,MAAAiB,QAAA,QAAAI,OAGAsC,YAQAjE,SAAA,SAAAkB,QAEA,IAAAb,OAAAT,MAAAS,OAAAT,IAAAI,SACA,KAAA,IAAAmB,WAAA;AAGA,MAAA,IAAAhC,SAAA,SAAAoE,QAAA/B,QACAvC,EAAAoF,aAAAhE,OAAAT,IAAAI,UACAsE,WAAA,OACAN,MAAA9C,OAAAA,QACAqD,gBAAA,SAAAJ,QACAZ,QAAAY,SAEAK,aAAA,SAAA7C,KACAH,OAAAG,gBChdA9C,OAAA,yCACA,SACA,SACA,SACA,4BACA,WACA,oCACA,sBACA,SAAAI,EAAAC,EAAAuF,OAAAnF,QAAAoF,UAAAC,sBAAAC,YACA,YAMA,IAAAC,KACAC,IAAA,kBACAC,IAAA,gBAOAC,aACAnF,IAAA6E,UAAAO,MAAA,MAAAJ,GAAAC,IAAAD,GAAAE,KACAjF,QAAA4E,UAAAO,MAAA,UAAAJ,GAAAC,IAAAD,GAAAE,KACAhF,IAAA2E,UAAAO,MAAA,SAAAJ,GAAAC,IAAAD,GAAAE;AACA/E,SAAA0E,UAAAO,MAAA,WAAAJ,GAAAC,IAAAD,GAAAE,KACAG,SAAAR,UAAAO,MAAA,WAAA,eAAA,YAOAE,UAAA,sBAKA,QACApC,MAAA,WAyFA,QAAAqC,WACA,GAAApB,OACAqB,MAAAF,UAKA,OAHAG,aAAAC,KAAA,WACAvB,KAAA/C,KAAAuE,MAAAvE,KAAAwE,QAEAzB,KAOA,QAAA0B,2BACA,GAAAC,UAAA,CACAL,aAAAC,KAAA,WAEA,MADAI,SAAA1E,KAAA2E,SAAAC,QAGAF,QACAG,cAAAC,WAAA,YAEAD,cAAAE,KAAA,WAAA,YASA,QAAAC,UAAAC,OACAC,WAAAC,YAAA,SAAApH,MAAAqH,WACA,OAAAA,UAAAC,MAAA,yBAAAC,KAAA,OAGAC,SAAA,aAAAN,MAAA,WAAA,eAAA;AACAC,WAAAM,SAAA,SAAAP,OACAQ,IAAAC,KAAAC,OAOA,QAAAC,YAAAxF,UACAyF,QAAAzF,SAAA0F,UAAA,aACAD,QAAAzF,SAAA0F,UAAA1F,SAAA2F,iBAAA,YASA,QAAAF,SAAAG,UAAAC,MACAC,WAAAD,OAAAC,WAAAD,MAAAE,KAAA3C,OAAA4C,KAAAJ,WAAAK,OAAA,QACAZ,IAAAQ,OAAAR,IAAAQ,MAAAK,OASA,QAAAC,gBAAAP,UAAAC,MACAJ,QAAAG,UAAAC,MACAf,WAAAM,SAAA,WA3JA,GAAAN,YAAAlH,EAAA,uBAKAwI,MAAAtB,WAAAuB,KAAA,QAOApC,YAAAmC,MAAAC,KAAA,iBAKA5B,cAAA2B,MAAAC,KAAA,iCAKAlB,SAAAiB,MAAAC,KAAA,6BAKAP,YACAQ,UAAAF,MAAAC,KAAA;AACAE,SAAAH,MAAAC,KAAA,gBACAG,WAAAJ,MAAAC,KAAA,mBAOAhB,IAAA,WACA,GAAAoB,OACAnB,KAAAc,MAAAC,KAAA,QAMA,OAJAI,MAAAnB,KAAApB,KAAA,WACA,GAAAwC,aAAA9I,EAAAgC,KACA6G,MAAA,IAAAC,YAAA/D,KAAA,SAAA+D,cAEAD,QAMAE,UAAArD,uBACA/E,KACAC,IAAAmF,YAAAnF,IACAC,QAAAkF,YAAAlF,QACAC,IAAAiF,YAAAjF,IACAC,SAAAgF,YAAAhF,UAEAC,sBACAC,UAAA+H,OAAAC,iBAAA/H,SAAA,MAEAC,mBACAF,UAAA,EAAAC,SAAA,MACAD,UAAA,EAAAC,SAAA,QAEAgI,GAAA,qBAAA,SAAAjH,OAAAG,UACA,cAAAA,SAAA3B,QACAuG,SAAA,WACAY,WAAAxF,UACAmG,eAAAnG,SAAA+G,UAAA,eAEA,WAAA/G,SAAA3B,QACAuG,SAAA;GAEAkC,GAAA,aAAA,SAAAjH,OAAAG,UACAwF,WAAAxF,YACA8G,GAAA,QAAA,WACAlC,SAAA,UAkFAE,YAAAuB,KAAA,iBAAAtB,YAAA,mBACAxB,WAAA7B,QAGAuC,YAAA6C,GAAA,mBAAAzC,yBAIAA,0BAGA+B,MAAAU,GAAA,SAAA,SAAAE,GACAA,EAAAC,iBACArC,SAAA,YACA+B,UAAAjE,OAAA9C,KAAA+B,OAAAoC,aAEAqC,MAAAC,KAAA,gCAAAS,GAAA,QAAA,SAAAE,GACAA,EAAAC,iBACArC,SAAA,UAGA3G,QAAA0F,YAAAE,UACA9D,KAAA,SAAAmH,aACA,GAAAA,aAAAA,YAAA7I,OACA,OAAA6I,YAAA7I,QACA,IAAA,SACAuG,SAAA,QACA,MACA,KAAA,YACAA,SAAA;AACAY,WAAA0B,aACAf,eAAAe,YAAAH,UAAA,aACA,MACA,SACAnC,SAAA,YACAY,WAAA0B,aACAP,UAAArE,WAAA4E,YAAAjH,QAIA2E,UAAA,OAEArB,YAAAlB,SAEAhC,MAAA,WACAuE,SAAA","file":"routes.js","sourcesContent":["/**\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; under version 2\n * of the License (non-upgradable).\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * Copyright (c) 2013 (original work) Open Assessment Technologies SA (under the project TAO-PRODUCT);\n *\n *\n */\ndefine('taoSync/controller/routes',[],function(){\n    'use strict';\n\n    return {\n        'Synchronizer': {\n            'actions' : {\n                'index' : 'taoSync/controller/synchronizer/index'\n            }\n        }\n    };\n});\n\n","/**\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; under version 2\n * of the License (non-upgradable).\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * Copyright (c) 2017 (original work) Open Assessment Technologies SA ;\n */\n\n/**\n * @example\n * taskQueueModelFactory({\n *        url : {\n *            get: urlHelper.route('get', 'TaskQueueWebApi', 'taoTaskQueue'),\n *            archive: urlHelper.route('archive', 'TaskQueueWebApi', 'taoTaskQueue'),\n *            all : urlHelper.route('getAll', 'TaskQueueWebApi', 'taoTaskQueue'),\n *            download : urlHelper.route('download', 'TaskQueueWebApi', 'taoTaskQueue')\n *        },\n *        pollSingleIntervals : [\n *            {iteration: 4, interval:1000},\n *        ],\n *        pollAllIntervals : [\n *            {iteration: 0, interval:5000},\n *        ]\n *    }).pollAll()\n */\ndefine('taoTaskQueue/model/taskQueueModel',[\n    'jquery',\n    'lodash',\n    'core/promise',\n    'core/eventifier',\n    'core/polling',\n    'core/dataProvider/request',\n    'jquery.fileDownload'\n], function ($, _, Promise, eventifier, polling, request) {\n    'use strict';\n\n    var _defaults = {\n        url : {\n            get: '',\n            archive: '',\n            all : '',\n            download : ''\n        },\n        pollSingleIntervals : [\n            {iteration: 4, interval:1000},\n        ],\n        pollAllIntervals : [\n            {iteration: 10, interval:5000},\n            {iteration: 0, interval:10000}//infinite\n        ]\n    };\n\n    /**\n     * Check if two tasks have equivalent task status\n     * @param {Object} task1 - a task object to be compared\n     * @param {Object} task2 - another task object to be compared\n     * @returns {Boolean}\n     */\n    function hasSameState(task1, task2){\n        if(task1.status === task2.status){\n            return true;\n        }else if(task1.status === 'created' || task1.status === 'in_progress'){\n            return  (task2.status === 'created' || task2.status === 'in_progress');\n        }\n        return false;\n    }\n\n    /**\n     * Create a task queue model to communicates with the server REST API\n     *\n     * @param {Object} config\n     * @param {Object} config.url - the list of server endpoints\n     * @param {String} config.url.get - the url to get the status log for a single task\n     * @param {String} config.url.archive - the url to archive a task\n     * @param {String} config.url.all - the url to get the status for all tasks for the current user\n     * @param {String} config.url.download - the url to download a file created by the task\n     * @param {Array} config.pollSingleIntervals - the array of poll intervals that will be used to regulate the polling speed for a simple task\n     *         e.g. {iteration: 4, interval:1000} means that it will poll up to four times every 1000ms.\n     * @param {Array} config.pollAllIntervals - the array of poll intervals that will be used to regulate the main polling speed.\n     *         e.g. {iteration: 10, interval:1000} means that it will poll up to 10 times every 5000ms.\n     *         e.g. {iteration: 0, interval:10000} means that it will poll up to 10000ms indefinitely\n     *\n     * @return {taskQueueModel}\n     */\n    return function taskQueueModel(config) {\n\n        var model;\n\n        /**\n         * cached array of task data\n         * @type {Object}\n         */\n        var _cache;\n\n        /**\n         * store instance of single polling\n         * @type {Object}\n         */\n        var singlePollings = {};\n\n        var getPollSingleIntervals = function getPollSingleIntervals(){\n            if(config.pollSingleIntervals && _.isArray(config.pollSingleIntervals)){\n                return _.cloneDeep(config.pollSingleIntervals);\n            }\n        };\n\n        var getPollAllIntervals = function getPollAllIntervals(){\n            if(config.pollAllIntervals && _.isArray(config.pollAllIntervals)){\n                return _.cloneDeep(config.pollAllIntervals);\n            }\n        };\n\n        config = _.defaults(config || {}, _defaults);\n\n        /**\n         * @typedef taskQueueModel - central model to query the backend's REST API for task queue\n         */\n        model = eventifier({\n\n            /**\n             * Modify the task queue REST API endpoints\n             * @param urls - the new endpoints\n             * @returns {taskQueueModel}\n             */\n            setEndpoints : function setEndpoints(urls){\n                _.assign(config.url, urls || {});\n                return this;\n            },\n\n            /**\n             * Get the status of a task identified by its unique task id\n             *\n             * @param {String} taskId - unique task identifier\n             * @returns {Promise}\n             */\n            get : function get(taskId){\n                var status;\n\n                if(!config.url || !config.url.get){\n                    throw new TypeError('config.url.get is not configured while get() is being called');\n                }\n\n                status = request(config.url.get, {taskId: taskId}, 'GET', {}, true)\n                    .then(function(taskData){\n                        //check taskData\n                        if(taskData && taskData.status){\n                            if(_cache){\n                                //detect change\n                                if(!_cache[taskData.id]){\n                                    model.trigger('singletaskadded', taskData);\n                                }else if(!hasSameState(_cache[taskData.id], taskData)){\n                                    //check if the status has changed\n                                    model.trigger('singletaskstatuschange', taskData);\n                                }\n                            }else{\n                                _cache = {};\n                            }\n                            _cache[taskData.id] = taskData;\n                            return taskData;\n                        }\n                        return Promise.reject(new Error('failed to get task data'));\n                    });\n\n                status.catch(function(err){\n                    model.trigger('error', err);\n                });\n\n                return status;\n            },\n\n            /**\n             * Get the status of all task identified by their unique task id\n             *\n             * @returns {Promise} - resolved when the server response has been received\n             */\n            getAll : function getAll(){\n                var status;\n\n                if(!config.url || !config.url.all){\n                    throw new TypeError('config.url.all is not configured while getAll() is being called');\n                }\n\n                status = request(config.url.all, {limit: 100}, 'GET', {}, true)\n                    .then(function(taskData){\n                        var newCache = {};\n                        //check taskData\n                        if(taskData){\n                            if(_cache){\n                                //detect change\n                                _.forEach(taskData, function(task){\n                                    var id = task.id;\n                                    if(!_cache[id]){\n                                        model.trigger('multitaskadded', task);\n                                    }else if(!hasSameState(_cache[id], task)){\n                                        //check if the status has changed\n                                        model.trigger('multitaskstatuschange', task);\n                                    }\n                                    newCache[id] = task;\n                                });\n                                _.forEach(_.difference(_.keys(_cache), _.keys(newCache)), function(id){\n                                    model.trigger('taskremoved', _cache[id]);\n                                });\n                            }else{\n                                _.forEach(taskData, function(task){\n                                    newCache[task.id] = task;\n                                });\n                            }\n                            //update local cache\n                            _cache = newCache;\n\n                            return taskData;\n                        }\n                        return Promise.reject(new Error('failed to get all task data'));\n                    });\n\n                status.catch(function(err){\n                    model.trigger('error', err);\n                });\n\n                return status;\n            },\n\n            /**\n             * Remove a task identified by its unique task id\n             *\n             * @param {String} taskId - the task id\n             * @returns {Promise} - resolved when achive action done\n             */\n            archive : function archive(taskId){\n\n                var status;\n\n                if(!config.url || !config.url.archive){\n                    throw new TypeError('config.url.archive is not configured while archive() is being called');\n                }\n\n                status = request(config.url.archive, {taskId : taskId}, 'GET', {}, true);\n\n                status.catch(function(res){\n                    model.trigger('error', res);\n                });\n\n                return status;\n            },\n\n            /**\n             * Poll status for all tasks\n             * @param {Boolean} [immediate] - tells if the polling should immediately start (otherwise, will wait until the next iteration)\n             * @returns {taskQueueModel}\n             */\n            pollAll : function pollAll(immediate){\n\n                var self = this;\n                var loop = 0;\n                var pollingIntervals = getPollAllIntervals();\n\n                /**\n                 * gradually increase the polling interval to ease server load\n                 * @private\n                 * @param {Object} pollingInstance - a poll object\n                 */\n                var _updateInterval = function _updateInterval(pollingInstance){\n                    var pollingInterval;\n                    if(loop){\n                        loop --;\n                    }else{\n                        pollingInterval = pollingIntervals.shift();\n                        if(pollingInterval && typeof pollingInterval.iteration !== 'undefined' && pollingInterval.interval){\n                            loop = pollingInterval.iteration;\n                            pollingInstance.setInterval(pollingInterval.interval);\n                        }\n                    }\n                };\n\n                if(!config.url || !config.url.all){\n                    throw new TypeError('config.url.all is not configured while pollAll() is being called');\n                }\n\n                if(!this.globalPolling){\n                    //no global polling yet, create one\n                    this.globalPolling = polling({\n                        action: function action() {\n                            // get into asynchronous mode\n                            var done = this.async();\n                            var statusArr;\n                            model.getAll().then(function(taskDataArray){\n                                model.trigger('pollAll', taskDataArray);\n\n                                //smart polling: stop polling when there is no task in progress\n                                statusArr = _.map(taskDataArray, 'status');\n                                if(statusArr.indexOf('in_progress') === -1 && statusArr.indexOf('created') === -1){\n                                    return done.reject();\n                                }\n\n                                _updateInterval(self.globalPolling);\n                                done.resolve();\n                            }).catch(function(){\n                                done.reject();\n                            });\n                        }\n                    });\n                    _updateInterval(this.globalPolling);\n                    this.globalPolling.start();\n                    this.trigger('pollAllStart');\n                }else{\n                    this.globalPolling.start();\n                    this.trigger('pollAllStart');\n                }\n\n                if(immediate){\n                    //if it is request to immediate start polling, start it now\n                    this.globalPolling.next();\n                }\n\n                return model;\n            },\n\n            /**\n             * Stop the main polling action\n             * @returns {taskQueueModel}\n             */\n            pollAllStop : function pollAllStop(){\n                if(this.globalPolling){\n                    this.globalPolling.stop();\n                    this.trigger('pollAllStop');\n                }\n                return this;\n            },\n\n            /**\n             * Start a single fast polling for a single task id\n             * @param {String} taskId - the task id\n             * @returns {Promise} resolved when the single polling action finishes\n             */\n            pollSingle : function pollSingle(taskId){\n\n                var self = this;\n                var loop = 0;\n\n                var pollingIntervals = getPollSingleIntervals();\n\n                /**\n                 * gradually increase the polling interval to ease server load\n                 * @private\n                 * @param {Object} pollingInstance - a poll object\n                 */\n                var _updateInterval = function _updateInterval(pollingInstance){\n                    var pollingInterval;\n                    if(loop){\n                        loop --;\n                        return true;//continue polling\n                    }else{\n                        pollingInterval = pollingIntervals.shift();\n                        if(pollingInterval && pollingInterval.iteration && pollingInterval.interval){\n                            loop = pollingInterval.iteration;\n                            pollingInstance.setInterval(pollingInterval.interval);\n                            return true;//continue polling\n                        }else{\n                            //stop polling\n                            return false;\n                        }\n                    }\n                };\n\n                if(!config.url || !config.url.get){\n                    throw new TypeError('config.url.get is not configured while pollSingle() is being called');\n                }\n\n                if(singlePollings[taskId]){\n                    singlePollings[taskId].stop();\n                }\n\n                return new Promise(function(resolve){\n                    var poll = polling({\n                        action: function action() {\n                            // get into asynchronous mode\n                            var done = this.async();\n                            self.get(taskId).then(function(taskData){\n                                if(taskData.status === 'completed' || taskData.status === 'failed'){\n                                    //the status status could be either \"completed\" or \"failed\"\n                                    poll.stop();\n                                    self.trigger('pollSingleFinished', taskId, taskData);\n                                    resolve({finished: true, task: taskData});\n                                }else if(!_updateInterval(poll)){\n                                    //if we have reached the end of the total polling config\n                                    self.trigger('pollSingleFinished', taskId, taskData);\n                                    resolve({finished: false, task: taskData});\n                                }else{\n                                    self.trigger('pollSingle', taskId, taskData);\n                                    done.resolve();//go to next poll iteration\n                                }\n\n                            }).catch(function(){\n                                done.reject();\n                            });\n                        }\n                    });\n                    _updateInterval(poll);\n                    singlePollings[taskId] = poll.start();\n                    self.trigger('pollSingleStart', taskId);\n                });\n            },\n\n            /**\n             * Interrupt a single polling action\n             * @param {String} taskId - the task id\n             * @returns {model}\n             */\n            pollSingleStop : function pollSingleStop(taskId){\n                if(singlePollings && singlePollings[taskId]){\n                    singlePollings[taskId].stop();\n                    this.trigger('pollSingleStop', taskId);\n                }\n                return this;\n            },\n\n            /**\n             * Call a task creation url\n             * @param {String} url - the server side task queue creation service\n             * @param {Object} [data] - request data\n             * @returns {promise} - resolved when task creation response is sent back by the server\n             */\n            create : function create(url, data){\n                var taskCreate, self = this;\n                taskCreate = request(url, data, 'POST', {}, true)\n                    .then(function(creationResult){\n                        //poll short result:\n                        if(creationResult && creationResult.task && creationResult.task.id){\n                            self.trigger('created', creationResult);\n                            return self.pollSingle(creationResult.task.id).then(function(result){\n                                if(creationResult.extra){\n                                    result.extra = creationResult.extra;\n                                }\n                                if(result.finished){\n                                    //send to queue\n                                    self.trigger('fastFinished', result);\n                                }else{\n                                    //send to queue\n                                    self.trigger('enqueued', result);\n                                }\n                                return result;\n                            });\n                        }\n                        return Promise.reject(new Error('failed to get task data'));\n                    });\n\n                taskCreate.catch(function(err){\n                    model.trigger('error', err);\n                });\n\n                return taskCreate;\n            },\n\n            /**\n             * Call the task result file download endpoint\n             * @param {String} taskId - the task id\n             * @returns {promise} - resolved when the download popup is shown\n             */\n            download : function download(taskId){\n\n                if(!config.url || !config.url.download){\n                    throw new TypeError('config.url.download is not configured while download() is being called');\n                }\n\n                return new Promise(function(resolve, reject){\n                    $.fileDownload(config.url.download, {\n                        httpMethod: 'POST',\n                        data: {taskId : taskId},\n                        successCallback : function(result){\n                            resolve(result);\n                        },\n                        failCallback: function (err) {\n                            reject(err);\n                        }\n                    });\n                });\n            }\n        });\n\n        return model;\n    };\n});\n","/**\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; under version 2\n * of the License (non-upgradable).\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n *\n * Copyright (c) 2018 Open Assessment Technologies SA\n */\n\ndefine('taoSync/controller/synchronizer/index',[\n    'jquery',\n    'lodash',\n    'moment',\n    'core/dataProvider/request',\n    'util/url',\n    'taoTaskQueue/model/taskQueueModel',\n    'layout/loading-bar'\n], function ($, _, moment, request, urlHelper, taskQueueModelFactory, loadingBar) {\n    'use strict';\n\n    /**\n     * TAO Extension and API of the taskQueue\n     * @type {Object}\n     */\n    var tq = {\n        api: 'TaskQueueWebApi',\n        ext: 'taoTaskQueue'\n    };\n\n    /**\n     * Urls of webservices\n     * @type {Object}\n     */\n    var webservices = {\n        get: urlHelper.route('get', tq.api, tq.ext),\n        archive: urlHelper.route('archive', tq.api, tq.ext),\n        all: urlHelper.route('getAll', tq.api, tq.ext),\n        download: urlHelper.route('download', tq.api, tq.ext),\n        lastTask: urlHelper.route('lastTask', 'Synchronizer', 'taoSync')\n    };\n\n    /**\n     * Task Label\n     * @type {String}\n     */\n    var taskLabel = 'Data Synchronization';\n\n    /**\n     * Initialize the application\n     */\n    return {\n        start: function start() {\n            /**\n             * Container\n             */\n            var $container = $('#tao-sync-container');\n\n            /**\n             * Form\n             */\n            var $form = $container.find('form');\n\n            /**\n             * Form fields, if any.\n             * Note that `:input` would include the button which is not wanted.\n             * Configured in config/taoSync/syncFormFields.conf.php\n             */\n            var $formFields = $form.find('input, select');\n\n            /**\n             * Launch button\n             */\n            var $launchButton = $form.find('button[data-control=\"launch\"]');\n\n            /**\n             * Spinners\n             */\n            var $spinner = $form.find('.feedback-info .icon-loop');\n\n            /**\n             * Start and update time\n             */\n            var timeFields = {\n                $enqueued: $form.find('.enqueue-time'),\n                $updated: $form.find('.update-time'),\n                $completed: $form.find('.complete-time')\n            };\n\n            /**\n             * Dynamic messages in the feedback boxes. These are based on the `data-type` elements\n             * and stored in the format msg.$foo to indicate that $foo is a jquery element.\n             */\n            var msg = (function () {\n                var _msg = {\n                    $all: $form.find('.msg')\n                };\n                _msg.$all.each(function () {\n                    var $currentMsg = $(this);\n                    _msg['$' + $currentMsg.data('type')] = $currentMsg;\n                });\n                return _msg;\n            }());\n\n            /**\n             * Task Queue object\n             */\n            var taskQueue = taskQueueModelFactory({\n                url: {\n                    get: webservices.get,\n                    archive: webservices.archive,\n                    all: webservices.all,\n                    download: webservices.download\n                },\n                pollSingleIntervals: [\n                    {iteration: Number.MAX_SAFE_INTEGER, interval: 2000}\n                ],\n                pollAllIntervals: [\n                    {iteration: 1, interval: 8000},\n                    {iteration: 0, interval: 5000}\n                ]\n            }).on('pollSingleFinished', function (taskId, taskData) {\n                if (taskData.status === 'completed') {\n                    setState('success');\n                    updateTime(taskData);\n                    setHistoryTime(taskData.updatedAt, '$completed');\n                }\n                else if (taskData.status === 'failed') {\n                    setState('error');\n                }\n            }).on('pollSingle', function (taskId, taskData) {\n                updateTime(taskData);\n            }).on('error', function () {\n                setState('error');\n            });\n\n            /**\n             * Get task parameters\n             *\n             * @returns {Object}\n             */\n            function getData() {\n                var data = {\n                    label: taskLabel\n                };\n                $formFields.each(function () {\n                    data[this.name] = this.value;\n                });\n                return data;\n            }\n\n            /**\n             * Dis/enable Launch Button depending on the state of fields\n             * that have any kind of HTML validator\n             */\n            function toggleLaunchButtonState() {\n                var isValid = true;\n                $formFields.each(function () {\n                    isValid = this.validity.valid;\n                    return isValid;\n                });\n                if (isValid) {\n                    $launchButton.removeAttr('disabled');\n                } else {\n                    $launchButton.attr('disabled', 'disabled');\n                }\n            }\n\n            /**\n             * Set the state to progress|success|error\n             *\n             * @param {String} state\n             */\n            function setState(state) {\n                $container.removeClass(function (index, className) {\n                    return (className.match(/(^|\\s)state-\\S+/g) || []).join(' ');\n                });\n                // make sure spinner doesn't use unnecessary resources\n                $spinner[state === 'progress' ? 'addClass' : 'removeClass']('spinner-icon');\n                $container.addClass('state-' + state);\n                msg.$all.hide();\n            }\n\n            /**\n             * Update the displayed times\n             * @param {Object} taskData\n             */\n            function updateTime(taskData) {\n                setTime(taskData.createdAt, '$enqueued');\n                setTime(taskData.createdAt + taskData.createdAtElapsed, '$updated');\n            }\n\n            /**\n             * Display time in a localized format\n             *\n             * @param {Number} timestamp\n             * @param {String} type\n             */\n            function setTime(timestamp, type) {\n                timeFields[type] && timeFields[type].text(moment.unix(timestamp).format('LTS'));\n                msg[type] && msg[type].show();\n            }\n\n            /**\n             * Display history time in a localized format\n             *\n             * @param {Number} timestamp\n             * @param {String} type\n             */\n            function setHistoryTime(timestamp, type) {\n                setTime(timestamp, type);\n                $container.addClass('history');\n            }\n\n            // avoids unwanted flicker caused by the late loading of the CSS\n            $container.find('.fb-container').removeClass('viewport-hidden');\n            loadingBar.start();\n\n            // check if all form fields are valid, if applicable\n            $formFields.on('keyup paste blur', toggleLaunchButtonState);\n\n            // there might be no form fields at all\n            // or they might have received valid entries by other means\n            toggleLaunchButtonState();\n\n            // set form actions\n            $form.on('submit', function (e) {\n                e.preventDefault();\n                setState('progress');\n                taskQueue.create(this.action, getData());\n            });\n            $form.find('button[data-control=\"close\"]').on('click', function (e) {\n                e.preventDefault();\n                setState('form');\n            });\n\n            request(webservices.lastTask)\n                .then(function (currentTask) {\n                    if (currentTask && currentTask.status) {\n                        switch (currentTask.status) {\n                            case 'failed':\n                                setState('error');\n                                break;\n                            case 'completed':\n                                setState('form');\n                                updateTime(currentTask);\n                                setHistoryTime(currentTask.updatedAt, '$completed');\n                                break;\n                            default:\n                                setState('progress');\n                                updateTime(currentTask);\n                                taskQueue.pollSingle(currentTask.id);\n                        }\n                    }\n                    else {\n                        setState('form');\n                    }\n                    loadingBar.stop();\n                })\n                .catch(function () {\n                    setState('error');\n                });\n        }\n    };\n});\n\n"]}